/*******************Задание 1) Написать ответ - почему массивы в JS являются "неправильными" и совмещают в себе несколько структур данных? Какие ? ******************************************/

//** Хотя массивы в JavaScript обеспечивают гибкость, они также могут привести к ошибкам, неоптимальности и путанице.Вот несколько моментов, которые следует учитывать: **/

/**1. Массивы могут хранить элементы разных типов, напоминающие хеш - таблицы, где ключи — это индексы, а значения — это элементы массива.Однако это может привести к непредсказуемому поведению при обходе или сортировке массива. */

var arr = [];
arr[0] = "apple";
arr["color"] = "red";
console.log(arr); // ["apple", color: "red"]
console.log(arr.length); // 1
console.log(arr["color"]); // "red"

/**2. Массивы в JavaScript являются динамическими и могут динамически изменять свою длину, напоминая списки, которые могут увеличиваться и уменьшаться по мере необходимости. Эта гибкость может быть полезной, но она также может привести к ошибкам при доступе к элементам или манипулировании ими. */

var arr = [1, 2, 3];
arr.length = 5;
console.log(arr); // [1, 2, 3, undefined, undefined]
console.log(arr.length); // 5

/**3. Массивы в JavaScript имеют такие методы , как pushи pop, которые напоминают стеки и следуют принципу «последним пришел — первым вышел» (LIFO). Они позволяют добавлять и удалять элементы с конца */
var arr = [1, 2, 3];
arr.push(4);
console.log(arr); // [1, 2, 3, 4]
console.log(arr.pop()); // 4
console.log(arr); // [1, 2, 3]

/* 4. Массивы в JavaScript также имеют такие методы, как shift и unshift, напоминающие очереди, следующие принципу «первым пришел – первым обслужен» (FIFO).Они позволяют добавлять и удалять элементы с начала массива. **/
var arr = [1, 2, 3];
arr.unshift(0);
console.log(arr); // [0, 1, 2, 3]
console.log(arr.shift()); // 0
console.log(arr); // [1, 2, 3]

/**Хотя эти функции обеспечивают гибкость, важно отметить недостатки и потенциальные ловушки использования массивов в JavaScript:
 * не гарантируют порядок элементов, если они используются в качестве хэш-таблиц.
  * не выполняют проверку типов элементов, если они используются в качестве хэш-таблиц.
 * могут потреблять больше памяти по сравнению со специализированными структурами данных.
 * могут иметь пустые или неопределенные ячейки, если они используются в качестве списков. */


/**************Задание 2) Привязать контекст объекта к функции logger, чтобы при вызове this.item выводило - some value(Привязать через bind, call, apply)

function logger () {
    console.log(`I output only external context: ${this.item}`);
}

const obj = { item: "some value" }; *****************************/

function logger() {
  console.log(`I output only external context: ${this.item}`);
}

const obj = { item: "some value" };

// Привязка obj context к logger function
const boundLogger = logger.bind(obj);

// Вызов ogger function
boundLogger(); // Output: I output only external context: some value

// Вызов logger function with the obj context using call
logger.call(obj); // Output: I output only external context: some value

// Вызов logger function с obj context и пустым массивом с помощью apply
logger.apply(obj, []); // Output: I output only external context: some value

/**В  коде logger функция определяется как функция, которая регистрирует внешний контекст item свойство.   obj объект создается с item свойство установлено на "some value".   bind метод используется для создания новой функции boundLogger, который привязан к objконтекст.  Когда boundLogger вызывается, он регистрирует внешний контекст item свойство. 

Кроме того, call метод используется для прямого вызова logger функция с obj контекст, и apply метод используется для вызова loggerфункция с objконтекст и пустой массив аргументов. 

Все три метода ( bind,  call, и apply) достичь того же результата вывода внешнего контекста item свойство. */

/* Бонус задание: Реализовать полифил(собственную функцию реализующую встроенную в js) метода bind()*/

/**Полифил для метода bind() - это код, который реализует функциональность метода bind() в браузерах, которые его не поддерживают.Метод bind() создает новую функцию с привязанным контекстом и аргументами, которую можно вызвать позже.*/
/*Чтобы реализовать полифилл для bind()метод в JavaScript, можно использовать следующий код, чтобы проверить, существует ли метод в Function.prototypeи добавить его, только если он еще не определен:*/ 

if (!Function.prototype.bind) {
    Function.prototype.bind = function (context, ...args) {
        const fn = this; // Reference to the original function
        return function (...innerArgs) {
            return fn.apply(context, args.concat(innerArgs));
        };
    };
}
/**Этот полифилл создает новую функцию, которая служит оболочкой для исходной функции (fn) и устанавливает желаемый контекст, используя apply().Он объединяет аргументы, переданные во время исходного bind()вызов(args) с аргументами, переданными при вызове связанной функции (innerArgs).*/ 

function greet (name) {
    console.log(`Hello, ${name}! I'm ${this.role}.`);
}

const person = {
    role: 'developer',
};

const boundGreet = greet.bind(person, 'John');
boundGreet(); // Output: Hello, John! I'm developer.

/**В этом примере greet()функция привязана к personобъект с использованием полифилла bind()метод.   personобъект заменен на thisзначение внутри greet()функция и дополнительные аргументы 'John'передаются в процессе привязки. 

Когда boundGreet()вызывается, он вызывает оригинал greet()функцию с предоставленным контекстом и аргументами, что приводит к ожидаемому результату. 

Важно отметить, что в современных условиях bind()метод уже встроен и не требует полифилла.  Однако эта пользовательская реализация служит примером того, как bind()метод может быть реализован, если он изначально недоступен */