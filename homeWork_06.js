/**Домашнее задание(Порешать типовые задачи - написать порядок и вывод в консоли):**/

/************************************  1)  *********************************/
// Выводим '1' в консоль синхронно
console.log('1');

// Планируем асинхронное выполнение функции обратного вызова для вывода '2' в консоль через 1 миллисекунду
setTimeout(() => console.log('2'), 1);

// Создаем промис, который сразу же разрешается со значением undefined и выводит '3' в консоль синхронно
let promiseNew = new Promise((resolve) => {
    console.log('3');
    resolve();
});

// Добавляем метод then к промису, который принимает функцию обратного вызова для вывода '4' в консоль при разрешении промиса
promiseNew.then(() => console.log('4'));

// Планируем асинхронное выполнение другой функции обратного вызова для вывода '5' в консоль через 0 миллисекунд (по умолчанию)
setTimeout(() => console.log('5'));

// Выводим '6' в консоль синхронно
console.log('6');

// output: 1 3 6 4 2 5

/************************************ 2)  ************************************/

// Создаем промис с помощью конструктора new Promise и передаем в него функцию-исполнитель
let promiseTree = new Promise((resolve, reject) => {
    // Разрешаем промис со значением "a"
    resolve("a");

    // Выводим "1" в консоль синхронно
    console.log("1");

    // Планируем асинхронное выполнение функции обратного вызова для вывода "2" в консоль через 0 миллисекунд (по умолчанию)
    setTimeout(() => {
        console.log("2");
    }, 0);

    // Выводим "3" в консоль синхронно
    console.log("3");
});

// output: 1 3 2


/************************************  3)  *********************************/

/* Создаем промис, который сразу же разрешается со значением "a" */
let promiseTwo = new Promise((resolve, reject) => {
    resolve("a");
});

promiseTwo
    // Добавляем метод then, который принимает функцию, которая вызывается с разрешенным значением и возвращает новое значение "ab"
    .then((res) => {
        return res + "b";
    })
    // Добавляем еще один метод then, который принимает функцию, которая вызывается с предыдущим значением и возвращает новое значение "abc"
    .then((res) => {
        return res + "с";
    })
    // Добавляем метод finally, который выполняется в любом случае, но не получает никакого значения и не изменяет результат
    .finally((res) => {
        return res + "!!!!!!!";
    })
    // Добавляем метод catch, который принимает функцию, которая вызывается в случае отклонения промиса, но это не происходит в этом примере
    .catch((res) => {
        return res + "d";
    })
    // Добавляем последний метод then, который принимает функцию, которая вызывается с конечным значением и выводит его в консоль
    .then((res) => {
        console.log(res);
    });
// output: abc



/*******************************  4)  ****************************/

// Создаем функцию doSmth, которая возвращает промис, разрешенный со значением "123"
function doSmth () {
    return Promise.resolve("123");
}

// Вызываем функцию doSmth и добавляем методы then и catch к возвращаемому промису
doSmth()
    // Добавляем первый метод then, который принимает функцию обратного вызова для вывода "1" и значения промиса в консоль
    .then(function (a) {
        console.log("1", a); // Выводит "1 123"
        return a; // Возвращает значение "123" для следующего промиса
    })
    // Добавляем второй метод then, который принимает функцию обратного вызова для вывода "2" и значения промиса в консоль
    .then(function (b) {
        console.log("2", b); // Выводит "2 123"
        return Promise.reject("321"); // Возвращает отклоненный промис со значением "321"
    })
    // Добавляем метод catch, который принимает функцию обратного вызова для вывода "3" и значения отклоненного промиса в консоль
    .catch(function (err) {
        console.log("3", err); // Выводит "3 321"
    })
    // Добавляем последний метод then, который принимает функцию обратного вызова для вывода "4" и значения промиса в консоль
    .then(function (c) {
        console.log("4", c); // Выводит "4 undefined", потому что предыдущий catch не вернул никакого значения
        return c; // Возвращает значение undefined для следующего промиса
    });

// output: 1 123 2 123 3 321 4 undefined

/***************************  5) **************************************/

// Выводим "1" в консоль синхронно
console.log("1");

// Планируем асинхронное выполнение функции обратного вызова для вывода "2" в консоль через 0 миллисекунд (по умолчанию)
setTimeout(function () {
    console.log("2");
}, 0);

// Создаем промис, который сразу же разрешается со значением undefined и добавляем метод then к нему
Promise.resolve().then(() => console.log("3"));

// Выводим "4" в консоль синхронно
console.log("4");

// Вывод в консоль: 1 4 3 2


/*************************************  6)  *******************************************/
/*  Напишите функцию, которая будет проходить через массив целых чисел и выводить индекс каждого элемента с задержкой в 3 секунды.
Входные данные: [10, 12, 15, 21] **/

function outputIndexesWithDelay (array) {
    array.forEach((element, index) => {
        setTimeout(() => {
            console.log(index);
        }, index * 3000);
    });
}

// Example usage:
const inputArray = [10, 12, 15, 21];
outputIndexesWithDelay(inputArray);

/*output
0
1
2
3*/

/** В этой функции outputIndexesWithDelay, мы используем forEach метод для перебора каждого элемента array.  Для каждого элемента, планируется setTimeout функция, которая выводит индекс на консоль после задержки.  Задержка вычисляется путем умножения индекса на 3000 миллисекунд (3 секунды), поэтому каждый индекс выводится с 3-секундной задержкой по сравнению с предыдущим. 

Если вызвать outputIndexesWithDelay с inputArray [10, 12, 15, 21], он выведет индексы 0,  1,  2, и 3 на консоль с 3-секундной задержкой между каждым выводом. **/

/** Mожно улучшить данное решение и добавить проверку на то, что входной параметр действительно является массивом целых чисел, иначе функция может выдать ошибку или неправильный результат. Например, вы можете использовать функцию Array.isArray для проверки типа параметра и метод every для проверки того, что все элементы массива являются целыми числами.**/

function outputIndexesWithDelay (array) {
    // Проверяем, что параметр является массивом
    if (!Array.isArray(array)) {
        console.error("Invalid input: expected an array of integers");
        return;
    }
    // Проверяем, что все элементы массива являются целыми числами
    if (!array.every(Number.isInteger)) {
        console.error("Invalid input: expected an array of integers");
        return;
    }
    // Проходим по массиву и выводим индексы с задержкой
    array.forEach((element, index) => {
        setTimeout(() => {
            console.log(index);
        }, index * 3000);
    });
}

// Example usage:
const inputArray = [10, 12, 15, 21];
outputIndexesWithDelay(inputArray);

/*output
0
1
2
3*/
/**Благодаря проверке входных данных функция теперь будет выдавать сообщения об ошибках, если входные данные не являются массивом или если какой-либо элемент в массиве не является целым числом. */

/*************************************** 7 ******************************************/
// Прочитать про Top Level Await (можно ли использовать await вне функции async)

/*Ожидание верхнего уровня — это функция ECMAScript, позволяющая использовать await ключевое слово вне асинхронной функции.  Он предоставляет возможность ожидания промисов на верхнем уровне модуля или скрипта, что делает код более читабельным и лаконичным.  Перед ожиданием верхнего уровня, awaitможет использоваться только внутри асинхронной функции. 

Ключевые моменты, которые нужно понять об ожидании верхнего уровня: 
    1.	Доступность. Ожидание верхнего уровня доступно в модулях ECMAScript, которые обычно используются
в современных средах JavaScript. Он недоступен в сценариях или модулях CommonJS. 
    2.	Синтаксис: Чтобы использовать ожидание верхнего уровня, вы можете просто использовать
команду awaitключевое слово, за которым следует обещание. Выполнение будет приостановлено до тех пор, пока обещание не будет выполнено, а затем результат будет присвоен переменной. */

// В модуле ES
const data = await fetch("https://example.com/data.json");
console.log(data);


/*  3.	Преимущества: Await верхнего уровня улучшает читабельность и понятность кода, позволяя напрямую использовать awaitвместо цепочки .then()обратные вызовы или использование асинхронных функций. 
    4.	Ограничения: Ожидание верхнего уровня имеет некоторые ограничения и последствия. Это влияет на
порядок выполнения модулей в графе зависимостей. Если модуль импортирует другой модуль, который использует ожидание верхнего уровня, импортирующий модуль будет ждать завершения импортированного модуля, прежде чем выполнять свой собственный код. Это может привести к задержкам или ошибкам при загрузке модуля. 
    5.	Предостережение при использовании: Ожидание верхнего уровня следует использовать разумно и 
только в случае необходимости.  В некоторых случаях с помощью асинхронных функций или .then()синтаксис может быть более подходящим и избежать потенциальных проблем с порядком выполнения модуля. 
    Важно отметить, что поддержка ожидания верхнего уровня может различаться в зависимости от
используемой вами среды JavaScript. Прежде чем полагаться на эту функцию, рекомендуется проверить конкретную документацию и информацию о совместимости для целевой среды. 
/* 
•	https://v8.dev/features/top-level-await Блог V8 - Ожидание высшего уровня 
•	https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await Веб-документы MDN — ожидание 
•	https://stackoverflow.com/questions/46515764/how-can-i-use-async-await-at-the-top-level Stack Overflow - Как я могу использовать async/await на верхнем уровне? 
*/