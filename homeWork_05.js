// 1) Какие бывают алгоритмы сортировок ?
/** Алгоритм сортировки — это алгоритм для упорядочивания элементов в списке по какому-то критерию Существует много разных алгоритмов сортировок, которые имеют разную сложность, скорость и эффективность. Некоторые из наиболее известных алгоритмов сортировок: */

/*1.1.Сортировка пузырьком: самый простой алгоритм, который сравнивает соседние элементы и меняет их местами, если они не упорядочены. Повторяет процесс до тех пор, пока все элементы не будут отсортированы. Этот алгоритм имеет квадратичную сложность O(n^2) и медленно работает на больших данных.
 */
// Функция для сортировки пузырьком
function bubbleSort (array) {
    // Переменная для обмена элементов
    let swap;
    // Цикл по всем элементам массива
    for (let i = 0; i < array.length; i++) {
        // Предполагаем, что обмен не нужен
        swap = false;
        // Цикл по оставшимся элементам массива
        for (let j = 0; j < array.length - i - 1; j++) {
            // Если текущий элемент больше следующего
            if (array[j] > array[j + 1]) {
                // Меняем их местами
                [array[j], array[j + 1]] = [array[j + 1], array[j]];
                // Запоминаем, что был обмен
                swap = true;
            }
        }
        // Если обменов не было, значит массив отсортирован
        if (!swap) break;
    }
    // Возвращаем отсортированный массив
    return array;
}

// Создаем тестовый массив
let testArray = [7, 3, 1, 9, 10, 2, 3, 6, 9, 4, 7, 5, 5, 4, 2, 8, 4, 7];

// Вызываем функцию сортировки пузырьком на тестовом массиве
bubbleSort(testArray);

// Выводим отсортированный массив в консоль
console.log(testArray); // Output: [1, 2, 2, 3, 3, 4, 4, 4, 5, 5, 6, 7, 7, 7, 8, 9, 9, 10]

/** 1.2. Сортировка вставками: алгоритм, который выбирает один элемент за другим и вставляет его на правильное место в уже отсортированной части массива. Этот алгоритм также имеет квадратичную сложность O(n^2), но работает быстрее сортировки пузырьком на небольших данных. */

// Функция для сортировки вставками
function insertionSort (array) {
    // Цикл по всем элементам массива, начиная со второго
    for (let i = 1; i < array.length; i++) {
        // Запоминаем текущий элемент
        let current = array[i];
        // Индекс для сдвига элементов
        let j = i - 1;
        // Пока индекс неотрицательный и предыдущий элемент больше текущего
        while (j >= 0 && array[j] > current) {
            // Сдвигаем предыдущий элемент вправо
            array[j + 1] = array[j];
            // Уменьшаем индекс
            j--;
        }
        // Вставляем текущий элемент на освободившееся место
        array[j + 1] = current;
    }
    // Возвращаем отсортированный массив
    return array;
}
// Создаем тестовый массив
let testArray = [7, 3, 1, 9, 10, 2, 3, 6, 9, 4, 7, 5, 5, 4, 2, 8, 4, 7];

// Вызываем функцию сортировки пузырьком на тестовом массиве
insertionSort(testArray);

// Выводим отсортированный массив в консоль
console.log(testArray); // Output: [1, 2, 2, 3, 3, 4, 4, 4, 5, 5, 6, 7, 7, 7, 8, 9, 9, 10]

/**1.3. Сортировка выбором: алгоритм, который находит наименьший элемент в неотсортированной части массива и ставит его в начало. Повторяет процесс до тех пор, пока все элементы не будут отсортированы. Этот алгоритм также имеет квадратичную сложность O(n^2), но делает меньше обменов элементов, чем сортировка пузырьком. */

// Функция для сортировки выбором
function selectionSort (array) {
    // Цикл по всем элементам массива
    for (let i = 0; i < array.length; i++) {
        // Запоминаем индекс наименьшего элемента
        let minIndex = i;
        // Цикл по оставшимся элементам массива
        for (let j = i + 1; j < array.length; j++) {
            // Если текущий элемент меньше наименьшего
            if (array[j] < array[minIndex]) {
                // Обновляем индекс наименьшего элемента
                minIndex = j;
            }
        }
        // Если наименьший элемент не на своём месте
        if (minIndex !== i) {
            // Меняем его местами с первым элементом неотсортированной части
            [array[i], array[minIndex]] = [array[minIndex], array[i]];
        }
    }
    // Возвращаем отсортированный массив
    return array;
}
// Создаем тестовый массив
let testArray = [7, 3, 1, 9, 10, 2, 3, 6, 9, 4, 7, 5, 5, 4, 2, 8, 4, 7];

// Вызываем функцию сортировки пузырьком на тестовом массиве
selectionSort(testArray);

// Выводим отсортированный массив в консоль
console.log(testArray); // Output: [1, 2, 2, 3, 3, 4, 4, 4, 5, 5, 6, 7, 7, 7, 8, 9, 9, 10]

/* 1.4. Сортировка слиянием: алгоритм, который разбивает массив на две половины, рекурсивно сортирует каждую из них и затем сливает их в один отсортированный массив. Этот алгоритм имеет логарифмическую сложность O(n log n) и работает быстрее квадратичных алгоритмов на больших данных, но требует дополнительного пространства для хранения промежуточных массивов. */

// Функция для сортировки слиянием
function mergeSort (array) {
    // Если массив состоит из одного элемента или пустой, возвращаем его
    if (array.length <= 1) return array;
    // Находим середину массива
    let middle = Math.floor(array.length / 2);
    // Разбиваем массив на две половины
    let left = array.slice(0, middle);
    let right = array.slice(middle);
    // Рекурсивно сортируем каждую половину
    left = mergeSort(left);
    right = mergeSort(right);
    // Сливаем отсортированные половины в один массив
    return merge(left, right);
}

// Функция для слияния двух отсортированных массивов
function merge (left, right) {
    // Создаём пустой массив для результата
    let result = [];
    // Пока оба массива не пустые
    while (left.length && right.length) {
        // Сравниваем первые элементы обоих массивов
        if (left[0] <= right[0]) {
            // Добавляем меньший элемент в результат и удаляем его из соответствующего массива
            result.push(left.shift());
        } else {
            result.push(right.shift());
        }
    }
    // Добавляем оставшиеся элементы из обоих массивов в результат
    return result.concat(left, right);
}

// Создаем тестовый массив
let testArray = [7, 3, 1, 9, 10, 2, 3, 6, 9, 4, 7, 5, 5, 4, 2, 8, 4, 7];

// Вызываем функцию сортировки слиянием на тестовом массиве и присваиваем результат переменной sortedArray
let sortedArray = mergeSort(testArray);

// Выводим отсортированный массив в консоль
console.log(sortedArray); // Output: [1, 2, 2, 3, 3, 4, 4, 4, 5, 5, 6, 7, 7, 7, 8, 9, 9, 10]

/**  1.5. Сортировка быстрая: алгоритм, который выбирает опорный элемент в массиве, переставляет остальные элементы так, чтобы слева от опорного были меньшие, а справа — большие, и затем рекурсивно сортирует левую и правую части. Этот алгоритм также имеет логарифмическую сложность O(n log n) в среднем случае, но может деградировать до квадратичной сложности O(n^2) в худшем случае. Этот алгоритм работает быстрее сортировки слиянием на небольших данных и не требует дополнительного пространства для хранения промежуточных массивов. Однако этот алгоритм неустойчив, то есть может нарушать порядок равных элементов.*/

// Функция для  быстрой сортировки
function quickSort (array) {
    // Если массив состоит из одного элемента или пустой, возвращаем его
    if (array.length <= 1) return array;
    // Выбираем опорный элемент (например, последний)
    let pivot = array[array.length - 1];
    // Создаём пустые массивы для меньших и больших элементов
    let left = [];
    let right = [];
    // Цикл по всем элементам массива, кроме опорного
    for (let i = 0; i < array.length - 1; i++) {
        // Если текущий элемент меньше или равен опорному
        if (array[i] <= pivot) {
            // Добавляем его в массив меньших элементов
            left.push(array[i]);
        } else {
            // Иначе добавляем его в массив больших элементов
            right.push(array[i]);
        }
    }
    // Рекурсивно сортируем меньшие и большие элементы
    left = quickSort(left);
    right = quickSort(right);
    // Возвращаем объединённый отсортированный массив
    return left.concat(pivot, right);

}
// Создаем тестовый массив
let testArray = [7, 3, 1, 9, 10, 2, 3, 6, 9, 4, 7, 5, 5, 4, 2, 8, 4, 7];

// Вызываем функцию сортировки пузырьком на тестовом массиве
quickSort(testArray);

// Выводим отсортированный массив в консоль
console.log(testArray); // Output: [1, 2, 2, 3, 3, 4, 4, 4, 5, 5, 6, 7, 7, 7, 8, 9, 9, 10]

/* 1.5. Алгоритм сортировки Array.prototype.sort(): массивы JavaScript имеют встроенный sort метод, который можно использовать для сортировки элементов на месте.По умолчанию элементы сортируются в лексикографическом(словарном) порядке.**/

const numbers = [4, 2, 1, 3, 5];
numbers.sort();
console.log(numbers)
    ; // Output: [1, 2, 3, 4, 5]

/** Чтобы отсортировать элементы в пользовательском порядке или на основе определенного критерия, можно передать методу функцию сравнения sort. Функция сравнения должна возвращать отрицательное значение, если первый элемент должен быть отсортирован перед вторым, положительное значение, если первый элемент должен быть отсортирован после второго, или 0, если элементы равны. **/

const numbers = [4, 2, 1, 3, 5];
numbers.sort((a, b) => a - b);
console.log(numbers)
    ; // Output: [1, 2, 3, 4, 5]

/*Это дополнительный алгоритм сортировки, который использует встроенный метод sort массивов JavaScript.Этот метод удобен, когда вам нужно отсортировать массив без создания нового массива или написания своего алгоритма.Однако этот метод может работать по - разному в разных браузерах или версиях JavaScript, поэтому важно проверять его результаты и сравнивать их с ожидаемыми.Также этот метод может быть неэффективным для сортировки больших массивов или массивов с нестандартными типами данных.*/

/**Для больших данных и нестандартных типов данных выбор алгоритма сортировки зависит от разных факторов, таких как доступная память, требуемая скорость, устойчивость и простота реализации.В общем случае, алгоритмы с логарифмической сложностью O(n log n), такие как сортировка слиянием и сортировка быстрая, будут работать эффективнее, чем алгоритмы с квадратичной сложностью O(n ^ 2), такие как сортировка пузырьком, сортировка вставками и сортировка выбором  Однако для небольших данных или почти отсортированных данных квадратичные алгоритмы могут быть быстрее или проще в реализации.
 * Для специальных случаев(типов данных) существуют более эффективные алгоритмы.Например, для целочисленных данных можно использовать поразрядную сортировку, которая имеет линейную сложность O(n) и работает за счет распределения элементов по корзинам в соответствии с их разрядами  Другой пример — сортировка подсчетом, которая также имеет линейную сложность O(n) и работает за счет подсчета количества вхождений каждого элемента в массиве и затем формирования отсортированного массива на основе этих подсчетов Эти алгоритмы подходят для данных, которые имеют ограниченный диапазон значений и не требуют устойчивости.
 * В некоторых случаях можно использовать комбинацию разных алгоритмов сортировки для достижения лучшего результата.Например, можно использовать сортировку быструю для разбиения массива на меньшие части, а затем использовать сортировку вставками для сортировки каждой части.Такой подход называется гибридной сортировкой и может улучшить производительность и устойчивость алгоритма */

/** Задание 2 Прочитать про "Операторы и выражения, циклы в JS */
/**2.1.Операторы:*/

/**2.1.1.Арифметические операторы: +, -, *, /, % (остаток), ++ (приращение), -- (уменьшение)
2.1.2. Операторы присваивания: =, +=, -=, *=, /=, %=
2.1.3. Операторы сравнения: ==, ===, !=, !==, >, <, >=, <=
2.1.4. Логические операторы: && (И), || (ИЛИ), ! (НЕТ)
2.1.5. Условный (тернарный) оператор: условие ? выражение1 : выражение2
2.1.6. Оператор typeof: переменная typeof */

/**2.2. Выражение — это комбинация переменных, значений и операторов, которая создает значение.*/
/*Примеры:

2.2.1. Арифметическое выражение:3 + 4 * 2
2.2.2. Строковое выражение:'Hello, ' + name
2.2.3. Логическое выражение:age >= 18 && hasLicense 
2.2.4. Циклы (Loops):

Цикл for: выполняет блок кода в течение определенного количества итераций.*/

for (initialization; condition; iteration) {
    // Code to be executed
}
/**Цикл while: выполняет блок кода, пока заданное условие истинно*/
while (condition) {
    // Code to be executed
}
/**Цикл Do-while: подобен циклу while, но код выполняется хотя бы один раз перед проверкой условия. */
do {
    // Code to be executed
} while (condition);
// Пример:
for (let i = 0; i < 5; i++) {
    console.log(i);
}
/**3) Создать объект Person несколькими способами, после создать объект Person2, чтобы в нём были доступны методы объекта Person. Добавить метод logInfo чтоб он был доступен всем объектам. */

// 3.1. Метод литерал объекта
// Person object constructor
function Person (name, age) {
    this.name = name;
    this.age = age;
}

// Метод Person object
Person.prototype.greet = function () {
    console.log('Hello, my name is ' + this.name);
};

// Person2 object constructor
function Person2 (name, age) {
    // Call the Person constructor with the provided arguments
    Person.call(this, name, age);
}

// Наследование методов Person object в Person2 object
Person2.prototype = Object.create(Person.prototype);

// ДобавляемlogInfo метод в Person prototype
Person.prototype.logInfo = function () {
    console.log('Name: ' + this.name + ', Age: ' + this.age);
};

//Создаем Person object
var person1 = new Person('Alice', 25);
person1.greet(); // Output: Hello, my name is Alice
person1.logInfo(); // Output: Name: Alice, Age: 25

//Создаем Person2 object
var person2 = new Person2('Bob', 30);
person2.greet(); // Output: Hello, my name is Bob
person2.logInfo(); // Output: Name: Bob, Age: 30

/**Сначала определяем Person объект со свойствами name и age, а также greet метод, который регистрирует приветственное сообщение.
 * Затем мы создаем Person2 объект, используя Object.create(Person). Это устанавливает цепочку прототипов, поэтому Person2 наследует свойства и методы от Person.
 * Добавляем logInfo к Person объекту метод, который также доступен объекту Person2 через цепочку прототипов. Оба объекта Personи Person2могут вызывать greetметод и logInfoметод, и у них будет доступ к общим свойствам и методам. */

// 3.2. Использование конструктора объектов:
const Person = new Object();
Person.name = 'John';
Person.age = 30;
Person.greet = function () {
    console.log(`Hello, my name is ${this.name} and I'm ${this.age} years old.`);
};

const Person2 = new Object(Person);
Person2.name = 'Jane';

Person.greet();    // Output: Hello, my name is John and I'm 30 years old.
Person2.greet();   // Output: Hello, my name is Jane and I'm 30 years old.

// 3.3 Использование функции конструктора:
function Person (name, age) {
    this.name = name;
    this.age = age;
    this.greet = function () {
        console.log(`Hello, my name is ${this.name} and I'm ${this.age} years old.`);
    };
}

const person = new Person('John', 30);
const person2 = new Person('Jane', 25);

person.greet();    // Output: Hello, my name is John and I'm 30 years old.
person2.greet();   // Output: Hello, my name is Jane and I'm 25 years old.

// 3.3. Используя метод Object.create:
const Person = {
    name: 'John',
    age: 30,
    greet () {
        console.log(`Hello, my name is ${this.name} and I'm ${this.age} years old.`);
    },
};

const Person2 = Object.create(Person, {
    name: { value: 'Jane' },
});

Person.greet();    // Output: Hello, my name is John and I'm 30 years old.
Person2.greet();   // Output: Hello, my name is Jane and I'm 30 years old.

/**Все три примера достигают одного и того же результата создания Person объекта и Person2 объекта с общими методами. Они демонстрируют различные способы создания объектов в JavaScript. */

/** Задание 4. Создать класс PersonThree c get и set для поля name и конструкторам, сделать класс наследник от класса Person. */

/** PersonThree класс расширяет Person класс с помощью extends ключевого слова. Он имеет свой собственный nameage параметр и super() метод используется в конструкторе для PersonThree вызова конструктора родительского класса и установки свойства name. Метод greet() переопределяется в PersonThreeклассе, чтобы обеспечить пользовательскую реализацию.
* Класс PersonThreeнаследует name свойство и методы получения/установки от Personкласса. nameВы можете получить доступ к свойствам объектов и изменить их PersonThreeс помощью методов getter/setter получения и установки*/

class Person {
    constructor(name) {
        this._name = name;
    }

    get name () {
        return this._name;
    }

    set name (newName) {
        this._name = newName;
    }

    greet () {
        console.log(`Hello, my name is ${this._name}.`);
    }
}

class PersonThree extends Person {
    constructor(name, age) {
        super(name);
        this.age = age;
    }

    greet () {
        console.log(`Hello, my name is ${this.name} and I'm ${this.age} years old.`);
    }
}

const personThree = new PersonThree('John', 30);
console.log(personThree.name);  // Output: John
personThree.name = 'Jane';
console.log(personThree.name);  // Output: Jane
personThree.greet();            // Output: Hello, my name is Jane and I'm 30 years old.

/**БОНУС: 
1) Написать функцию, которая вернет массив с первой парой чисел, сумма которых равна total:

arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];
total = 13;
//result = [4, 9]

const firstSum = (arr, total) => {
      //Решение
}

firstSum(arr,total) 
2) Какая сложность у вашего алгоритма ? */

/**Чтобы найти первую пару чисел в массиве arr, сумма которых равна заданному total, попробуем использовать вложенный цикл для сравнения каждой пары чисел. Вот пример реализации функции firstSum: */

const firstSum = (arr, total) => {
    for (let i = 0; i < arr.length; i++) {
        for (let j = i + 1; j < arr.length; j++) {
            if (arr[i] + arr[j] === total) {
                return [arr[i], arr[j]];
            }
        }
    }
    return [];
};

const arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];
const total = 13;
const result = firstSum(arr, total);

console.log(result); // Output: [4, 9]


/**Алгоритм работы следующий:
 * Перебрать каждый элемент массива с помощью вложенного цикла.
 * Для каждого элемента по индексу iвыполните итерацию по оставшимся элементам в массиве, начиная с индекса i+1.
 * Проверьте, равна ли сумма текущего элемента по индексу iи элемента по индексу внутреннего цикла общему количеству.j
 * Если сумма равна итогу, вернуть массив, содержащий пару чисел.
 * Если пара не найдена, верните пустой массив, чтобы указать, что такой пары не существует.
 * Сложность этого алгоритма составляет O(n^2), где n — длина входного массива. Это связано с тем, что есть два вложенных цикла, заставляющих алгоритм перебирать каждую пару чисел в массиве. С увеличением размера массива количество итераций растет квадратично
 * Хотя этот алгоритм работает для небольших входных данных, он может стать неэффективным для больших массивов из-за своей квадратичной временной сложности. */

/** Если массив отсортирован в порядке возрастания, можно использовать подход с двумя указателями. 
 *  Инициализиция двух указателей, i и j, где i указывает на начало массива (индекс 0), а j указывает на конец массива (индекс arr.length - 1).
 * Используется цикл, который будет продолжаться до тех пор, пока i < j.
 * Вычисляется сумма элементов с индексами i и j, т. е. sum = arr[i] + arr[j].
 * Сравниваем сумму с целевым итогом.
 * а. Если сумма равна сумме, значит, мы нашли искомую пару чисел. Возвращает пару [arr[i], arr[j]].
 * б. Если сумма меньше суммы, увеличьте указатель i на 1, чтобы перейти к большему числу, поскольку массив сортируется в порядке возрастания.
 * в. Если сумма больше суммы, уменьшите указатель j на 1, чтобы перейти к меньшему числу, поскольку массив сортируется в порядке возрастания.
 * Повторяются шаги 3-4, пока либо пара не будет найдена, либо i не станет больше или равным j.
 * Если цикл завершается, не найдя пары, вернется пустой массив [], чтобы указать, что такой пары не существует.

Алгоритм использует тот факт, что массив отсортирован, что позволяет эффективно искать пару чисел, сумма которых равна сумме, путем настройки указателей на основе сравнения суммы с суммой. Этот подход устраняет необходимость в дополнительных структурах данных и обеспечивает временную сложность O(n), где n — длина массива*/

  const findPair = (arr, total) => {
  let i = 0;
  let j = arr.length - 1;

  while (i < j) {
    const sum = arr[i] + arr[j];

    if (sum === total) {
      return [arr[i], arr[j]];
    } else if (sum < total) {
      i++;
    } else {
      j--;
    }
  }

  return [];
};

const arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];
const total = 13;
const result = findPair(arr, total);

console.log(result); // Output: [4, 9]
